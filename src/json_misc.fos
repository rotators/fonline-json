/******************************************************************************
 *                                                                            *
 *  Miscellaneous macros and functions used in the module.                    *
 *                                                                            *
 ******************************************************************************/

/**
 *  Compatibility macros.
 *
 *  Macros for manipulating raw characters in a string.
 */
#ifdef _JSON_REV_PRE400
    #define _CharGet    #(s, i)    s[i]
    #define _CharSet    #(s, i, v) s[i] = v
    #define _CharAdd    #(s, v)    s.resize(s.length() + 1); \
                                   s[s.length() - 1] = v
    #define _CharLength #(s)       s.length()
    #define _CharResize #(s, v)    s.resize(v)
#endif

#ifndef _JSON_REV_PRE400
    #define _CharGet    #(s, i)    s.rawGet(i)
    #define _CharSet    #(s, i, v) s.rawSet(i, v)
    #define _CharAdd    #(s, v)    s.rawResize(s.rawLength() + 1); \
                                   s.rawSet(s.rawLength() - 1, v)
    #define _CharLength #(s)       s.rawLength()
    #define _CharResize #(s, v)    s.rawResize(v)
#endif

/**
 *  Other macros.
 */
#define _IsWhitespace   #(c)       (c == 9 || c == 10 || c == 13 || c == 32)

/**
 *  controlChars table.
 *
 *  Array with JSON-compatible escape codes of control characters (0x00 - 0x1F).
 *  Used by Escape() function.
 */
array<string> controlChars = {
    "\\u0000",  "\\u0001",  "\\u0002",  "\\u0003",
    "\\u0004",  "\\u0005",  "\\u0006",  "\\u0007",
    "\\b",      "\\t",      "\\n",      "\\u000B",
    "\\f",      "\\r",      "\\u000E",  "\\u000F",
    "\\u0010",  "\\u0011",  "\\u0012",  "\\u0013",
    "\\u0014",  "\\u0015",  "\\u0016",  "\\u0017",
    "\\u0018",  "\\u0019",  "\\u001A",  "\\u001B",
    "\\u001C",  "\\u001D",  "\\u001E",  "\\u001F"
};

/**
 * Indent table.
 *
 * Used by JSON::stringify(uint space).
 */
array<string> indent = {
    "",
    " ",
    "  ",
    "   ",
    "    ",
    "     ",
    "      ",
    "       ",
    "        ",
    "         ",
    "          "
};

/**
 *  JSON String escaping.
 */
string@ EscapeString(string& str)
{
    string@ escapedString = "";
    uint length = _CharLength(str);
    uint8 ch = 0;
    for (uint i = 0; i < length; i++)
    {
        ch = _CharGet(str, i);
        if (ch == 34 || ch == 92)
        {
            _CharAdd(escapedString, 92);
            _CharAdd(escapedString, ch);
        }
        else if (ch < 32)
        {
            escapedString += controlChars[ch];
        }
        else
        {
            _CharAdd(escapedString, ch);
        }
    }
    return escapedString;
}

////////////////////////////////////////////////////////////////////////////////
//
//  StrToDouble
//  Converts a string to a double. Used when evaluating a NUMBER token.
//  TODO: Check the precision of numbers larger than float, change return value
//  to bool, return the number by reference and false if conversion failed.
//
double StrToDouble(string@ str)
{
    int length = _CharLength(str);
    int position = _CharLength(str) - 1;
    int count = 0;
    int symbol = 0;
    int value = 0;
    int exponent = 0;

    while (position >= 0)
    {
        symbol = _CharGet(str, position);

        switch (symbol)
        {
            case 43:  // + sign
            {
                break;
            }
            case 45:  // - sign
            {
                value = -value;
                break;
            }
            case 46:  // . decimal point
            {
                exponent += -count;
                break;
            }
            case 48:  // 0
            case 49:  // 1
            case 50:  // 2
            case 51:  // 3
            case 52:  // 4
            case 53:  // 5
            case 54:  // 6
            case 55:  // 7
            case 56:  // 8
            case 57:  // 9
            {
                value += (symbol - 48) * int(pow(10, count));
                count++;
                break;
            }
            case 69:  // E
            case 101: // e
            {
                exponent = value;
                value = 0;
                count = 0;
                break;
            }
            default:
            {
                return 0;
            }
        }
        position -= 1;
    }
    return double(value) * double(pow(10, exponent));
}


////////////////////////////////////////////////////////////////////////////////
//
//  Stringification
//  Converts a JSON value(s) into a JSON text.
//
string@ Stringify(JSON@ value, const string& space, string& indent)
{
    if (@value == null || value.isUndefined())
    {
        return "";
    }
    else if (value.isNull())
    {

        return "null";
    }
    else if (value.isBoolean())
    {
        bool v = false;
        value >> v;
        if (v)
        {
            return "true";
        }
        return "false";
    }
    else if (value.isNumber())
    {
        double v = 0;
        value >> v;
        string s = "" + v;
        for (uint i = 0, j = _CharLength(s); i < j; i++)
        {
            if (_CharGet(s, i) == ',')
            {
                _CharSet(s, i, '.');
                break;
            }
        }
        return s;
    }
    else if (value.isString())
    {
        string s;
        value >> s;
        s = "\"" + EscapeString(s) + "\"";
        return s;
    }

    string s = "";
    bool compact = (space.length() == 0);
    string newIndent = indent + space;

    if (value.isObject())
    {
        s = (compact ? "{" : "{\n");
        array<string> keys = value.getKeys();
        for (uint i = 0, j = keys.length(); i < j; i++)
        {
            s += newIndent + "\"" + keys[i] + (compact ? "\":" : "\": ");
            s += Stringify(value[keys[i]], space, newIndent);
            if (i < j - 1)
            {
                s += (compact ? "," : ",\n");
            }
        }
        s += (compact ? "}" : "\n" + indent + "}");
    }
    else if (value.isArray())
    {
        s = (compact ? "[" : "[\n");
        for (uint i = 0, j = value.length(); i < j; i++)
        {
            s += newIndent + Stringify(value[i], space, newIndent);
            if (i < j - 1)
            {
                s += (compact ? "," : ",\n");
            }
        }
        s += (compact ? "]" : "\n" + indent + "]");
    }
    return s;
}
